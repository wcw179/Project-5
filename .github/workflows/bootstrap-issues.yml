name: Bootstrap Issues, Labels, Milestones

on:
  workflow_dispatch:
  push:
    branches:
      - main
    paths:
      - '.github/workflows/bootstrap-issues.yml'
      - 'project-management/**'

permissions:
  contents: read
  issues: write

jobs:
  bootstrap:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Bootstrap Project (Milestones, Labels, Issues)
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { owner, repo } = context.repo;

            async function processMilestones(core, github) {
              core.info('--- 1. Processing Milestones ---');
              const path = 'project-management/milestones.json';
              if (!fs.existsSync(path)) {
                core.warning('No milestones.json found, skipping.');
                return new Map();
              }

              const data = JSON.parse(fs.readFileSync(path, 'utf8'));
              const existing = await github.paginate(github.rest.issues.listMilestones, { owner, repo, state: 'open', per_page: 100 });
              const map = new Map(existing.map(m => [m.title, m.number]));

              for (const m of data) {
                const due_on = new Date(m.due_on).toISOString();
                if (map.has(m.title)) {
                  const number = map.get(m.title);
                  await github.rest.issues.updateMilestone({ owner, repo, milestone_number: number, title: m.title, due_on });
                  core.info(`Updated milestone: ${m.title}`);
                } else {
                  await github.rest.issues.createMilestone({ owner, repo, title: m.title, due_on });
                  core.info(`Created milestone: ${m.title}`);
                }
              }
              // Return a fresh map for the issues step
              const finalMilestones = await github.paginate(github.rest.issues.listMilestones, { owner, repo, state: 'open', per_page: 100 });
              return new Map(finalMilestones.map(m => [m.title, m.number]));
            }

            async function processLabels(core, github) {
              core.info('--- 2. Processing Labels ---');
              const path = 'project-management/labels.json';
              if (!fs.existsSync(path)) {
                core.warning('No labels.json found, skipping.');
                return;
              }

              const data = JSON.parse(fs.readFileSync(path, 'utf8'));
              const existing = await github.paginate(github.rest.issues.listLabelsForRepo, { owner, repo, per_page: 100 });
              const map = new Map(existing.map(l => [l.name, l]));

              for (const l of data) {
                const name = l.name;
                const color = (l.color || '777777').replace('#','');
                if (map.has(name)) {
                  await github.rest.issues.updateLabel({ owner, repo, name, new_name: name, color });
                  core.info(`Updated label: ${name}`);
                } else {
                  await github.rest.issues.createLabel({ owner, repo, name, color });
                  core.info(`Created label: ${name}`);
                }
              }
            }

            function parseCSV(content) {
              const rows = [];
              let i = 0, field = '', row = [], inQuotes = false;
              while (i < content.length) {
                const c = content[i];
                if (inQuotes) {
                  if (c === '"') {
                    if (content[i+1] === '"') { field += '"'; i++; } else { inQuotes = false; }
                  } else { field += c; }
                } else {
                  if (c === '"') { inQuotes = true; }
                  else if (c === ',') { row.push(field); field=''; }
                  else if (c === '\n' || c === '\r') {
                    if (field.length || row.length) { row.push(field); rows.push(row); }
                    field=''; row=[];
                    if (c === '\r' && content[i+1] === '\n') i++;
                  } else { field += c; }
                }
                i++;
              }
              if (field.length || row.length) { row.push(field); rows.push(row); }
              return rows;
            }

            async function processIssues(core, github, msMap) {
              core.info('--- 3. Processing Issues ---');
              const path = 'project-management/issues.csv';
              if (!fs.existsSync(path)) {
                core.warning('No issues.csv found, skipping.');
                return;
              }

              const content = fs.readFileSync(path, 'utf8');
              const rows = parseCSV(content).filter(r => r.length > 0 && r[0] !== 'Title');

              for (const r of rows) {
                const [Title, Body, Labels, Milestone] = r;
                const title = Title.trim();
                const body = Body.trim();
                const labels = (Labels || '').split('|').map(s => s.trim()).filter(Boolean);
                const msNumber = Milestone && msMap.has(Milestone) ? msMap.get(Milestone) : undefined;

                const q = `repo:${owner}/${repo} is:issue in:title "${title.replace(/"/g, '\"')}"`;
                const search = await github.rest.search.issuesAndPullRequests({ q, per_page: 1 });

                if (search.data.total_count > 0 && search.data.items[0].title === title) {
                  core.info(`Issue exists, skipping: ${title}`);
                  continue;
                }

                await github.rest.issues.create({ owner, repo, title, body, labels, milestone: msNumber });
                core.info(`Created issue: ${title}`);
              }
            }

            // --- Main Execution ---
            try {
              const msMap = await processMilestones(core, github);
              await processLabels(core, github);
              await processIssues(core, github, msMap);
              core.info('âœ… Bootstrap process completed successfully.');
            } catch (error) {
              core.setFailed(`Bootstrap process failed: ${error.message}`);
            }

